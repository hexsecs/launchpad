<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Launchpad Pro MK3 – Web MIDI Prototype</title>
    <style>
      :root {
        color-scheme: light;
        --bg: #0f141a;
        --panel: #18212b;
        --text: #e5eef7;
        --muted: #9bb0c4;
        --accent: #ffb703;
        --accent-2: #4cc9f0;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "Space Grotesk", "Avenir Next", "Helvetica Neue", sans-serif;
        background: radial-gradient(circle at top, #243142, #0f141a 60%);
        color: var(--text);
        min-height: 100vh;
        display: grid;
        place-items: center;
        padding: 32px;
      }
      main {
        width: min(920px, 100%);
        background: linear-gradient(135deg, #18212b, #111821);
        border: 1px solid #263547;
        border-radius: 18px;
        padding: 28px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
      }
      h1 {
        margin: 0 0 8px;
        font-size: clamp(1.6rem, 2.8vw, 2.2rem);
        letter-spacing: 0.02em;
      }
      p {
        margin: 0 0 16px;
        color: var(--muted);
        line-height: 1.5;
      }
      .row {
        display: grid;
        gap: 12px;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        margin-bottom: 16px;
      }
      button {
        appearance: none;
        border: 1px solid transparent;
        border-radius: 999px;
        padding: 10px 16px;
        font-weight: 600;
        background: var(--accent);
        color: #0c1116;
        cursor: pointer;
        transition: transform 0.12s ease, box-shadow 0.12s ease;
      }
      button.secondary {
        background: transparent;
        color: var(--text);
        border-color: #34485e;
      }
      button.secondary.active {
        background: var(--accent-2);
        color: #0c1116;
        border-color: transparent;
        box-shadow: 0 6px 16px rgba(76, 201, 240, 0.35);
      }
      button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }
      button:not(:disabled):hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 16px rgba(255, 183, 3, 0.35);
      }
      select {
        width: 100%;
        background: #111821;
        color: var(--text);
        border: 1px solid #2a3c4f;
        border-radius: 10px;
        padding: 10px 12px;
      }
      .log {
        font-family: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, monospace;
        font-size: 0.9rem;
        background: #0d131a;
        border: 1px solid #1e2a36;
        border-radius: 10px;
        padding: 12px;
        min-height: 180px;
        max-height: 240px;
        overflow: auto;
        white-space: pre-wrap;
      }
      .status {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-weight: 600;
      }
      .dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #f44336;
        box-shadow: 0 0 8px rgba(244, 67, 54, 0.6);
      }
      .dot.ok {
        background: #7ae582;
        box-shadow: 0 0 8px rgba(122, 229, 130, 0.6);
      }
      footer {
        margin-top: 12px;
        color: var(--muted);
        font-size: 0.85rem;
      }
    </style>
  </head>
  <body>
    <main>
      <h1>Launchpad Pro MK3 – Web MIDI Prototype</h1>
      <p>
        Connects to the Launchpad Pro MK3 via Web MIDI, switches to Programmer Mode, lights a few pads,
        and echoes pad presses to the log.
      </p>
      <div class="row">
        <button id="connect">Connect MIDI</button>
        <button id="enterProg" class="secondary" disabled>Enter Programmer Mode</button>
        <button id="exitProg" class="secondary" disabled>Exit Programmer Mode</button>
        <button id="lightDemo" class="secondary" disabled>Light Demo Pads</button>
        <button id="rainbowDiag" class="secondary" disabled>Rainbow Diagonal</button>
        <button id="lifeMode" class="secondary" disabled>Game of Life</button>
        <button id="ticTacToe" class="secondary" disabled>Tic Tac Toe</button>
        <button id="connectFour" class="secondary" disabled>Connect Four</button>
        <button id="connectFourAi" class="secondary" disabled>Connect Four (1P)</button>
        <button id="clear" class="secondary" disabled>Clear All</button>
      </div>
      <div class="row">
        <label>
          MIDI Input
          <select id="midiIn"></select>
        </label>
        <label>
          MIDI Output
          <select id="midiOut"></select>
        </label>
        <div class="status" id="status">
          <span class="dot" id="statusDot"></span>
          <span id="statusText">Disconnected</span>
        </div>
      </div>
      <div class="log" id="log"></div>
      <footer>
        Tip: use Chrome or Edge and enable System Exclusive access when prompted.
      </footer>
    </main>

    <script>
      const connectBtn = document.getElementById("connect");
      const enterProgBtn = document.getElementById("enterProg");
      const exitProgBtn = document.getElementById("exitProg");
      const lightDemoBtn = document.getElementById("lightDemo");
      const rainbowDiagBtn = document.getElementById("rainbowDiag");
      const lifeModeBtn = document.getElementById("lifeMode");
      const ticTacToeBtn = document.getElementById("ticTacToe");
      const connectFourBtn = document.getElementById("connectFour");
      const connectFourAiBtn = document.getElementById("connectFourAi");
      const clearBtn = document.getElementById("clear");
      const midiInSelect = document.getElementById("midiIn");
      const midiOutSelect = document.getElementById("midiOut");
      const logEl = document.getElementById("log");
      const statusDot = document.getElementById("statusDot");
      const statusText = document.getElementById("statusText");

      let midiAccess;
      let midiIn;
      let midiOut;
      let rainbowTimer;
      let rainbowRunning = false;
      let lifeTimer;
      let lifeRunning = false;
      let tttRunning = false;
      let tttBoard = null;
      let tttTurn = "X";
      let tttWinner = null;
      let tttWinLine = null;
      let tttWinTimer = null;
      let tttWinPulsing = false;
      let tttPadColors = new Map();
      let c4Running = false;
      let c4Board = null;
      let c4Turn = 1;
      let c4Winner = null;
      let c4WinLine = null;
      let c4WinTimer = null;
      let c4WinPulsing = false;
      let c4DropTimer = null;
      let c4Dropping = false;
      let c4AiEnabled = false;
      let c4AiPending = false;
      let c4PadColors = new Map();

      const log = (message) => {
        const timestamp = new Date().toLocaleTimeString();
        logEl.textContent += `[${timestamp}] ${message}\n`;
        logEl.scrollTop = logEl.scrollHeight;
      };

      const setStatus = (connected, label) => {
        statusDot.classList.toggle("ok", connected);
        statusText.textContent = label;
      };

      const refreshPorts = () => {
        midiInSelect.innerHTML = "";
        midiOutSelect.innerHTML = "";

        if (!midiAccess) return;

        for (const input of midiAccess.inputs.values()) {
          const option = document.createElement("option");
          option.value = input.id;
          option.textContent = input.name || input.id;
          midiInSelect.appendChild(option);
        }
        for (const output of midiAccess.outputs.values()) {
          const option = document.createElement("option");
          option.value = output.id;
          option.textContent = output.name || output.id;
          midiOutSelect.appendChild(option);
        }
      };

      const selectLaunchpadDefaults = () => {
        const preferNames = [/launchpad\\s+pro/i, /launchpad/i, /lpp3/i];
        const excludeNames = [/network/i, /live\\s+session/i];
        const pick = (selectEl) => {
          const options = Array.from(selectEl.options);
          const filtered = options.filter(
            (opt) => !excludeNames.some((rx) => rx.test(opt.textContent || ""))
          );
          for (const rx of preferNames) {
            const match = filtered.find((opt) => rx.test(opt.textContent || ""));
            if (match) {
              selectEl.value = match.value;
              return;
            }
          }
        };
        pick(midiInSelect);
        pick(midiOutSelect);
      };

      const attachInput = () => {
        if (midiIn) midiIn.onmidimessage = null;
        midiIn = midiAccess.inputs.get(midiInSelect.value) || null;
        if (midiIn) {
          midiIn.onmidimessage = (event) => {
            const data = Array.from(event.data).map((b) => b.toString(16).padStart(2, "0"));
            log(`IN  ${data.join(" ")}`);
            const status = event.data[0] & 0xf0;
            const note = event.data[1];
            const velocity = event.data[2];
            if (tttRunning && status === 0x90 && velocity > 0) {
              handleTttPress(note);
            } else if (c4Running && status === 0x90 && velocity > 0) {
              handleC4Press(note);
            }
          };
          log(`Listening to input: ${midiIn.name}`);
        }
      };

      const attachOutput = () => {
        midiOut = midiAccess.outputs.get(midiOutSelect.value) || null;
        if (midiOut) log(`Using output: ${midiOut.name}`);
      };

      const sendSysEx = (bytes) => {
        if (!midiOut) return;
        midiOut.send(bytes);
        const printable = bytes.map((b) => b.toString(16).padStart(2, "0")).join(" ");
        log(`OUT ${printable}`);
      };

      const sendCC = (status, cc, value) => {
        if (!midiOut) return;
        midiOut.send([status, cc, value]);
      };

      const sendNoteOn = (note, velocity) => {
        if (!midiOut) return;
        midiOut.send([0x90, note, velocity]);
        log(`OUT 90 ${note.toString(16).padStart(2, "0")} ${velocity
          .toString(16)
          .padStart(2, "0")}`);
      };

      const sendNoteOff = (note) => {
        if (!midiOut) return;
        midiOut.send([0x80, note, 0x00]);
      };

      const clearGrid = () => {
        for (let row = 1; row <= 8; row += 1) {
          for (let col = 1; col <= 8; col += 1) {
            const note = row * 10 + col;
            sendNoteOff(note);
          }
        }
        if (tttRunning) tttPadColors.clear();
        if (c4Running) c4PadColors.clear();
      };

      const applyTttFrame = (frame) => {
        const allNotes = new Set([...tttPadColors.keys(), ...frame.keys()]);
        for (const note of allNotes) {
          const prev = tttPadColors.get(note);
          const next = frame.get(note);
          if (prev === next) continue;
          if (next == null) {
            sendNoteOff(note);
            tttPadColors.delete(note);
          } else {
            sendNoteOn(note, next);
            tttPadColors.set(note, next);
          }
        }
      };

      const applyC4Frame = (frame) => {
        const allNotes = new Set([...c4PadColors.keys(), ...frame.keys()]);
        for (const note of allNotes) {
          const prev = c4PadColors.get(note);
          const next = frame.get(note);
          if (prev === next) continue;
          if (next == null) {
            sendNoteOff(note);
            c4PadColors.delete(note);
          } else {
            sendNoteOn(note, next);
            c4PadColors.set(note, next);
          }
        }
      };

      const OUTER_CCS = [
        90, 91, 92, 93, 94, 95, 96, 97, 98,
        89, 79, 69, 59, 49, 39, 29, 19,
        101, 102, 103, 104, 105, 106, 107, 108,
        99,
      ];

      const setOuterPulseColor = (color) => {
        for (const cc of OUTER_CCS) {
          sendCC(0xb2, cc, color);
        }
      };

      const clearOuterButtons = () => {
        for (const cc of OUTER_CCS) {
          sendCC(0xb0, cc, 0);
        }
      };

      const setRainbowUI = (on) => {
        rainbowDiagBtn.classList.toggle("active", on);
        rainbowDiagBtn.textContent = on ? "Stop Rainbow" : "Rainbow Diagonal";
      };

      const setLifeUI = (on) => {
        lifeModeBtn.classList.toggle("active", on);
        lifeModeBtn.textContent = on ? "Stop Game of Life" : "Game of Life";
      };

      const setTttUI = (on) => {
        ticTacToeBtn.classList.toggle("active", on);
        ticTacToeBtn.textContent = on ? "Stop Tic Tac Toe" : "Tic Tac Toe";
      };

      const setC4UI = (on) => {
        connectFourBtn.classList.toggle("active", on);
        connectFourBtn.textContent = on ? "Stop Connect Four" : "Connect Four";
      };

      const setC4AiUI = (on) => {
        connectFourAiBtn.classList.toggle("active", on);
        connectFourAiBtn.textContent = on ? "Stop Connect Four (1P)" : "Connect Four (1P)";
      };

      const stopLifeIfRunning = () => {
        if (!lifeRunning) return;
        clearInterval(lifeTimer);
        lifeTimer = null;
        lifeRunning = false;
        clearGrid();
        setLifeUI(false);
        log("Stopped Game of Life.");
      };

      const stopRainbowIfRunning = () => {
        if (!rainbowRunning) return;
        clearInterval(rainbowTimer);
        rainbowTimer = null;
        rainbowRunning = false;
        clearGrid();
        setRainbowUI(false);
        log("Stopped diagonal rainbow animation.");
      };

      const stopTttIfRunning = () => {
        if (!tttRunning) return;
        tttRunning = false;
        tttBoard = null;
        tttTurn = "X";
        tttWinner = null;
        tttWinLine = null;
        if (tttWinTimer) {
          clearInterval(tttWinTimer);
          tttWinTimer = null;
        }
        tttWinPulsing = false;
        applyTttFrame(new Map());
        clearOuterButtons();
        setTttUI(false);
        log("Stopped Tic Tac Toe.");
      };

      const stopC4IfRunning = () => {
        if (!c4Running) return;
        c4Running = false;
        c4Board = null;
        c4Turn = 1;
        c4Winner = null;
        c4WinLine = null;
        if (c4WinTimer) {
          clearInterval(c4WinTimer);
          c4WinTimer = null;
        }
        if (c4DropTimer) {
          clearInterval(c4DropTimer);
          c4DropTimer = null;
        }
        c4WinPulsing = false;
        c4Dropping = false;
        c4AiEnabled = false;
        c4AiPending = false;
        applyC4Frame(new Map());
        clearOuterButtons();
        setC4UI(false);
        setC4AiUI(false);
        log("Stopped Connect Four.");
      };

      connectBtn.addEventListener("click", async () => {
        try {
          midiAccess = await navigator.requestMIDIAccess({ sysex: true });
          log("MIDI access granted.");
          refreshPorts();
          midiAccess.onstatechange = () => {
            refreshPorts();
            selectLaunchpadDefaults();
            attachInput();
            attachOutput();
            log("MIDI ports changed.");
          };
          setStatus(true, "Connected");
          enterProgBtn.disabled = false;
          exitProgBtn.disabled = false;
          lightDemoBtn.disabled = false;
          rainbowDiagBtn.disabled = false;
          lifeModeBtn.disabled = false;
          ticTacToeBtn.disabled = false;
          connectFourBtn.disabled = false;
          connectFourAiBtn.disabled = false;
          clearBtn.disabled = false;
          if (midiInSelect.options.length) midiInSelect.selectedIndex = 0;
          if (midiOutSelect.options.length) midiOutSelect.selectedIndex = 0;
          selectLaunchpadDefaults();
          attachInput();
          attachOutput();
        } catch (error) {
          log(`Failed to get MIDI access: ${error.message}`);
        }
      });

      midiInSelect.addEventListener("change", attachInput);
      midiOutSelect.addEventListener("change", attachOutput);

      enterProgBtn.addEventListener("click", () => {
        // Launchpad Pro MK3 SysEx: F0 00 20 29 02 0E 0E 01 F7
        sendSysEx([0xf0, 0x00, 0x20, 0x29, 0x02, 0x0e, 0x0e, 0x01, 0xf7]);
        log("Entered Programmer Mode.");
      });

      exitProgBtn.addEventListener("click", () => {
        // Launchpad Pro MK3 SysEx: F0 00 20 29 02 0E 0E 00 F7
        sendSysEx([0xf0, 0x00, 0x20, 0x29, 0x02, 0x0e, 0x0e, 0x00, 0xf7]);
        log("Exited Programmer Mode.");
      });

      lightDemoBtn.addEventListener("click", () => {
        // Light all 8x8 pads with a simple color gradient.
        for (let row = 1; row <= 8; row += 1) {
          for (let col = 1; col <= 8; col += 1) {
            const note = row * 10 + col;
            const velocity = Math.min(127, 8 + row * 8 + col * 2);
            sendNoteOn(note, velocity);
          }
        }
      });

      clearBtn.addEventListener("click", () => {
        // Clear the 8x8 grid by sending Note Off to all grid notes (11-88).
        clearGrid();
        log("Cleared grid.");
      });

      rainbowDiagBtn.addEventListener("click", () => {
        if (rainbowRunning) {
          stopRainbowIfRunning();
          return;
        }
        stopLifeIfRunning();
        stopTttIfRunning();
        const palette = [5, 13, 21, 29, 45, 53, 61, 69];
        let step = 0;
        rainbowTimer = setInterval(() => {
          for (let row = 1; row <= 8; row += 1) {
            for (let col = 1; col <= 8; col += 1) {
              const note = row * 10 + col;
              const diag = (8 - row) + (8 - col);
              const color = palette[(diag + step) % palette.length];
              sendNoteOn(note, color);
            }
          }
          step = (step + 1) % palette.length;
        }, 120);
        rainbowRunning = true;
        setRainbowUI(true);
        log("Started diagonal rainbow animation.");
      });

      const tttBands = [
        [0, 1],
        [3, 4],
        [6, 7],
      ];
      const tttGridLines = [2, 5];

      const noteToRowCol = (note) => {
        const row = Math.floor(note / 10) - 1;
        const col = (note % 10) - 1;
        return { row, col };
      };

      const rowColToNote = (row, col) => (row + 1) * 10 + (col + 1);

      const bandIndex = (value) => {
        if (value <= 1) return 0;
        if (value <= 4) return 1;
        return 2;
      };

      const tttMap = new Map();
      for (let row = 0; row < 8; row += 1) {
        for (let col = 0; col < 8; col += 1) {
          tttMap.set(rowColToNote(row, col), { row: bandIndex(row), col: bandIndex(col) });
        }
      }

      const buildTttFrame = () => {
        const frame = new Map();
        const xColor = 5;
        const oColor = 45;
        const gridColor = 3;

        for (let cellRow = 0; cellRow < 3; cellRow += 1) {
          for (let cellCol = 0; cellCol < 3; cellCol += 1) {
            const value = tttBoard[cellRow][cellCol];
            if (!value) continue;
            const [rowStart, rowEnd] = tttBands[cellRow];
            const [colStart, colEnd] = tttBands[cellCol];
            const color = value === "X" ? xColor : oColor;
            for (let row = rowStart; row <= rowEnd; row += 1) {
              for (let col = colStart; col <= colEnd; col += 1) {
                frame.set(rowColToNote(row, col), color);
              }
            }
          }
        }

        for (const line of tttGridLines) {
          for (let col = 0; col < 8; col += 1) {
            frame.set(rowColToNote(line, col), gridColor);
          }
          for (let row = 0; row < 8; row += 1) {
            frame.set(rowColToNote(row, line), gridColor);
          }
        }
        return frame;
      };

      const renderTtt = () => {
        applyTttFrame(buildTttFrame());
      };

      const buildC4Frame = () => {
        const frame = new Map();
        const p1Color = 5;
        const p2Color = 45;
        for (let row = 0; row < 8; row += 1) {
          for (let col = 0; col < 8; col += 1) {
            const value = c4Board[row][col];
            if (!value) continue;
            frame.set(rowColToNote(row, col), value === 1 ? p1Color : p2Color);
          }
        }
        return frame;
      };

      const renderC4 = () => {
        applyC4Frame(buildC4Frame());
      };

      const renderC4WithDrop = (row, col, color) => {
        const frame = buildC4Frame();
        frame.set(rowColToNote(row, col), color);
        applyC4Frame(frame);
      };

      const checkC4Winner = (board = c4Board) => {
        const directions = [
          { dr: 0, dc: 1 },
          { dr: 1, dc: 0 },
          { dr: 1, dc: 1 },
          { dr: 1, dc: -1 },
        ];
        for (let row = 0; row < 8; row += 1) {
          for (let col = 0; col < 8; col += 1) {
            const value = board[row][col];
            if (!value) continue;
            for (const { dr, dc } of directions) {
              const line = [{ row, col }];
              for (let step = 1; step < 4; step += 1) {
                const r = row + dr * step;
                const c = col + dc * step;
                if (r < 0 || r >= 8 || c < 0 || c >= 8) break;
                if (board[r][c] !== value) break;
                line.push({ row: r, col: c });
              }
              if (line.length === 4) {
                return { winner: value, line };
              }
            }
          }
        }
        const filled = board.flat().every((cell) => cell);
        return filled ? { winner: "draw", line: null } : null;
      };

      const checkTttWinner = () => {
        const b = tttBoard;
        const lines = [
          [
            { row: 0, col: 0 },
            { row: 0, col: 1 },
            { row: 0, col: 2 },
          ],
          [
            { row: 1, col: 0 },
            { row: 1, col: 1 },
            { row: 1, col: 2 },
          ],
          [
            { row: 2, col: 0 },
            { row: 2, col: 1 },
            { row: 2, col: 2 },
          ],
          [
            { row: 0, col: 0 },
            { row: 1, col: 0 },
            { row: 2, col: 0 },
          ],
          [
            { row: 0, col: 1 },
            { row: 1, col: 1 },
            { row: 2, col: 1 },
          ],
          [
            { row: 0, col: 2 },
            { row: 1, col: 2 },
            { row: 2, col: 2 },
          ],
          [
            { row: 0, col: 0 },
            { row: 1, col: 1 },
            { row: 2, col: 2 },
          ],
          [
            { row: 0, col: 2 },
            { row: 1, col: 1 },
            { row: 2, col: 0 },
          ],
        ];
        for (const line of lines) {
          const [a, bCell, c] = line;
          const value = tttBoard[a.row][a.col];
          if (value && value === tttBoard[bCell.row][bCell.col] && value === tttBoard[c.row][c.col]) {
            return { winner: value, line };
          }
        }
        const filled = b.flat().every((cell) => cell);
        return filled ? { winner: "draw", line: null } : null;
      };

      const runTttWinAnimation = (winner) => {
        const winColor = winner === "X" ? 5 : 45;
        setOuterPulseColor(winColor);
        const fillHeights = Array.from({ length: 8 }, () => 0);
        const dropPositions = Array.from({ length: 8 }, () => -Math.floor(Math.random() * 4));
        tttWinTimer = setInterval(() => {
          const frame = new Map();
          for (let col = 0; col < 8; col += 1) {
            const height = fillHeights[col];
            if (height < 8) {
              let drop = dropPositions[col] + 1;
              const targetRow = 7 - height;
              if (drop >= targetRow) {
                fillHeights[col] = Math.min(8, height + 1);
                drop = -Math.floor(Math.random() * 3);
              } else {
                dropPositions[col] = drop;
                if (drop >= 0) {
                  frame.set(rowColToNote(drop, col), winColor);
                }
              }
            }
            for (let i = 0; i < fillHeights[col]; i += 1) {
              const row = 7 - i;
              frame.set(rowColToNote(row, col), winColor);
            }
          }
          applyTttFrame(frame);
          if (fillHeights.every((height) => height >= 8)) {
            const fullFrame = new Map();
            for (let row = 0; row < 8; row += 1) {
              for (let col = 0; col < 8; col += 1) {
                fullFrame.set(rowColToNote(row, col), winColor);
              }
            }
            applyTttFrame(fullFrame);
            clearInterval(tttWinTimer);
            tttWinTimer = null;
            if (tttWinLine) {
              const highlightColor = 3;
              const highlightFrame = new Map(fullFrame);
              for (const cell of tttWinLine) {
                const [rowStart, rowEnd] = tttBands[cell.row];
                const [colStart, colEnd] = tttBands[cell.col];
                for (let row = rowStart; row <= rowEnd; row += 1) {
                  for (let col = colStart; col <= colEnd; col += 1) {
                    highlightFrame.set(rowColToNote(row, col), highlightColor);
                  }
                }
              }
              let pulseOn = true;
              tttWinTimer = setInterval(() => {
                applyTttFrame(pulseOn ? highlightFrame : fullFrame);
                pulseOn = !pulseOn;
              }, 260);
              tttWinPulsing = true;
            }
          }
        }, 140);
      };

      const runC4WinAnimation = (winner) => {
        const winColor = winner === 1 ? 5 : 45;
        setOuterPulseColor(winColor);
        const fillHeights = Array.from({ length: 8 }, () => 0);
        const dropPositions = Array.from({ length: 8 }, () => -Math.floor(Math.random() * 4));
        c4WinTimer = setInterval(() => {
          const frame = new Map();
          for (let col = 0; col < 8; col += 1) {
            const height = fillHeights[col];
            if (height < 8) {
              let drop = dropPositions[col] + 1;
              const targetRow = 7 - height;
              if (drop >= targetRow) {
                fillHeights[col] = Math.min(8, height + 1);
                drop = -Math.floor(Math.random() * 3);
              } else {
                dropPositions[col] = drop;
                if (drop >= 0) {
                  frame.set(rowColToNote(drop, col), winColor);
                }
              }
            }
            for (let i = 0; i < fillHeights[col]; i += 1) {
              const row = 7 - i;
              frame.set(rowColToNote(row, col), winColor);
            }
          }
          applyC4Frame(frame);
          if (fillHeights.every((height) => height >= 8)) {
            const fullFrame = new Map();
            for (let row = 0; row < 8; row += 1) {
              for (let col = 0; col < 8; col += 1) {
                fullFrame.set(rowColToNote(row, col), winColor);
              }
            }
            applyC4Frame(fullFrame);
            clearInterval(c4WinTimer);
            c4WinTimer = null;
            if (c4WinLine) {
              const highlightColor = 3;
              const highlightFrame = new Map(fullFrame);
              for (const cell of c4WinLine) {
                highlightFrame.set(rowColToNote(cell.row, cell.col), highlightColor);
              }
              let pulseOn = true;
              c4WinTimer = setInterval(() => {
                applyC4Frame(pulseOn ? highlightFrame : fullFrame);
                pulseOn = !pulseOn;
              }, 260);
              c4WinPulsing = true;
            }
          }
        }, 140);
      };

      const runC4DrawAnimation = () => {
        if (c4WinTimer) {
          clearInterval(c4WinTimer);
          c4WinTimer = null;
        }
        const dimColor = 13;
        let step = 0;
        c4WinTimer = setInterval(() => {
          const frame = new Map();
          if (step % 2 === 0) {
            for (let row = 0; row < 8; row += 1) {
              for (let col = 0; col < 8; col += 1) {
                frame.set(rowColToNote(row, col), dimColor);
              }
            }
          }
          applyC4Frame(frame);
          step += 1;
          if (step >= 8) {
            clearInterval(c4WinTimer);
            c4WinTimer = null;
            c4Winner = null;
            c4WinLine = null;
            c4WinPulsing = false;
            c4Board = Array.from({ length: 8 }, () => Array(8).fill(null));
            c4Turn = 1;
            renderC4();
            setOuterPulseColor(5);
            log("Connect Four reset.");
          }
        }, 220);
      };

      const runTttDrawAnimation = () => {
        if (tttWinTimer) {
          clearInterval(tttWinTimer);
          tttWinTimer = null;
        }
        const baseColor = 13;
        const accentColor = 45;
        const toFrame = (coords, color) => {
          const frame = new Map();
          for (const [row, col] of coords) {
            frame.set(rowColToNote(row, col), color);
          }
          return frame;
        };
        const catFace = [
          [1, 1], [1, 6],
          [2, 2], [2, 5],
          [3, 1], [3, 6],
          [4, 2], [4, 5],
          [5, 1], [5, 6],
          [6, 2], [6, 3], [6, 4], [6, 5],
        ];
        const catBlink = [
          [2, 2], [2, 5],
          [4, 1], [4, 6],
          [5, 2], [5, 5],
          [6, 2], [6, 3], [6, 4], [6, 5],
        ];
        const whiskers = [
          [3, 0], [3, 1], [3, 2],
          [3, 5], [3, 6], [3, 7],
        ];
        const frameA = toFrame([...catFace, ...whiskers], baseColor);
        const frameB = toFrame([...catBlink, ...whiskers], accentColor);
        const frames = [frameA, frameB];

        let step = 0;
        tttWinTimer = setInterval(() => {
          applyTttFrame(frames[step % 2]);
          step += 1;
          if (step >= 10) {
            clearInterval(tttWinTimer);
            tttWinTimer = null;
            tttWinner = null;
            tttWinLine = null;
            tttWinPulsing = false;
            tttBoard = Array.from({ length: 3 }, () => Array(3).fill(null));
            tttTurn = "X";
            renderTtt();
            setOuterPulseColor(5);
            log("Tic Tac Toe reset.");
          }
        }, 220);
      };

      const handleTttPress = (note) => {
        if (!tttRunning) return;
        if (tttWinTimer && !tttWinPulsing) return;
        if (tttWinner) {
          tttWinner = null;
          tttWinLine = null;
          tttBoard = Array.from({ length: 3 }, () => Array(3).fill(null));
          tttTurn = "X";
          if (tttWinTimer) {
            clearInterval(tttWinTimer);
            tttWinTimer = null;
          }
          tttWinPulsing = false;
          renderTtt();
          setOuterPulseColor(5);
          log("Tic Tac Toe reset.");
          return;
        }
        const { row, col } = noteToRowCol(note);
        if (tttGridLines.includes(row) || tttGridLines.includes(col)) return;
        const cell = tttMap.get(note);
        if (!cell) return;
        if (tttBoard[cell.row][cell.col]) return;
        tttBoard[cell.row][cell.col] = tttTurn;
        const result = checkTttWinner();
        if (result) {
          tttWinner = result.winner;
          tttWinLine = result.line;
          renderTtt();
          if (result.winner === "draw") {
            clearOuterButtons();
            log("Tic Tac Toe: draw.");
            runTttDrawAnimation();
          } else {
            clearOuterButtons();
            log(`Tic Tac Toe: ${result.winner} wins.`);
            runTttWinAnimation(result.winner);
          }
          return;
        }
        tttTurn = tttTurn === "X" ? "O" : "X";
        renderTtt();
        setOuterPulseColor(tttTurn === "X" ? 5 : 45);
      };

      const handleC4Press = (note) => {
        if (!c4Running) return;
        if (c4WinTimer && !c4WinPulsing) return;
        if (c4Dropping) return;
        if (c4AiPending) return;
        if (c4AiEnabled && c4Turn === 2) return;
        if (c4Winner) {
          c4Winner = null;
          c4WinLine = null;
          c4Board = Array.from({ length: 8 }, () => Array(8).fill(null));
          c4Turn = 1;
          if (c4WinTimer) {
            clearInterval(c4WinTimer);
            c4WinTimer = null;
          }
          if (c4DropTimer) {
            clearInterval(c4DropTimer);
            c4DropTimer = null;
          }
          c4WinPulsing = false;
          c4Dropping = false;
          c4AiPending = false;
          renderC4();
          setOuterPulseColor(5);
          log("Connect Four reset.");
          return;
        }
        const { col } = noteToRowCol(note);
        runC4Drop(col);
      };

      const runC4Drop = (col) => {
        let targetRow = -1;
        for (let row = 0; row < 8; row += 1) {
          if (!c4Board[row][col]) {
            targetRow = row;
            break;
          }
        }
        if (targetRow === -1) return;
        const dropColor = c4Turn === 1 ? 5 : 45;
        let dropRow = 7;
        c4Dropping = true;
        if (c4DropTimer) {
          clearInterval(c4DropTimer);
          c4DropTimer = null;
        }
        c4DropTimer = setInterval(() => {
          renderC4WithDrop(dropRow, col, dropColor);
          if (dropRow === targetRow) {
            clearInterval(c4DropTimer);
            c4DropTimer = null;
            c4Dropping = false;
            c4Board[targetRow][col] = c4Turn;
            const result = checkC4Winner();
            if (result) {
              c4Winner = result.winner;
              c4WinLine = result.line;
              renderC4();
              clearOuterButtons();
              if (result.winner === "draw") {
                log("Connect Four: draw.");
                runC4DrawAnimation();
              } else {
                log(`Connect Four: ${result.winner === 1 ? "Red" : "Blue"} wins.`);
                runC4WinAnimation(result.winner);
              }
              return;
            }
            c4Turn = c4Turn === 1 ? 2 : 1;
            renderC4();
            setOuterPulseColor(c4Turn === 1 ? 5 : 45);
            if (c4AiEnabled && c4Turn === 2) scheduleC4AiMove();
            return;
          }
          dropRow -= 1;
        }, 80);
      };

      const scheduleC4AiMove = () => {
        if (!c4AiEnabled || !c4Running) return;
        if (c4WinTimer || c4Dropping || c4AiPending) return;
        c4AiPending = true;
        setTimeout(() => {
          c4AiPending = false;
          if (!c4AiEnabled || !c4Running) return;
          if (c4Turn !== 2 || c4Dropping || c4WinTimer) return;
          const col = pickC4AiColumn();
          if (col == null) return;
          runC4Drop(col);
        }, 220);
      };

      const pickC4AiColumn = () => {
        const available = [];
        for (let col = 0; col < 8; col += 1) {
          if (!c4Board[7][col]) available.push(col);
        }
        if (!available.length) return null;
        const tryColFor = (player) => {
          for (const col of available) {
            let targetRow = -1;
            for (let row = 0; row < 8; row += 1) {
              if (!c4Board[row][col]) {
                targetRow = row;
                break;
              }
            }
            if (targetRow === -1) continue;
            const copy = c4Board.map((r) => r.slice());
            copy[targetRow][col] = player;
            const result = checkC4Winner(copy);
            if (result && result.winner === player) return col;
          }
          return null;
        };
        const winCol = tryColFor(2);
        if (winCol != null) return winCol;
        const blockCol = tryColFor(1);
        if (blockCol != null) return blockCol;
        const center = [3, 4, 2, 5, 1, 6, 0, 7];
        for (const col of center) {
          if (available.includes(col)) return col;
        }
        return available[Math.floor(Math.random() * available.length)];
      };

      lifeModeBtn.addEventListener("click", () => {
        if (lifeRunning) {
          stopLifeIfRunning();
          return;
        }
        stopRainbowIfRunning();
        stopTttIfRunning();

        const size = 8;
        let grid = Array.from({ length: size }, () =>
          Array.from({ length: size }, () => Math.random() > 0.7)
        );

        const render = () => {
          for (let row = 0; row < size; row += 1) {
            for (let col = 0; col < size; col += 1) {
              const note = (row + 1) * 10 + (col + 1);
              if (grid[row][col]) {
                sendNoteOn(note, 60);
              } else {
                sendNoteOff(note);
              }
            }
          }
        };

        const stepLife = () => {
          const next = Array.from({ length: size }, () => Array(size).fill(false));
          for (let row = 0; row < size; row += 1) {
            for (let col = 0; col < size; col += 1) {
              let neighbors = 0;
              for (let dr = -1; dr <= 1; dr += 1) {
                for (let dc = -1; dc <= 1; dc += 1) {
                  if (dr === 0 && dc === 0) continue;
                  const r = row + dr;
                  const c = col + dc;
                  if (r >= 0 && r < size && c >= 0 && c < size && grid[r][c]) {
                    neighbors += 1;
                  }
                }
              }
              const alive = grid[row][col];
              next[row][col] = alive
                ? neighbors === 2 || neighbors === 3
                : neighbors === 3;
            }
          }
          grid = next;
          render();
        };

        render();
        lifeTimer = setInterval(stepLife, 250);
        lifeRunning = true;
        setLifeUI(true);
        log("Started Game of Life.");
      });

      ticTacToeBtn.addEventListener("click", () => {
        if (tttRunning) {
          stopTttIfRunning();
          return;
        }
        stopRainbowIfRunning();
        stopLifeIfRunning();
        stopC4IfRunning();
        clearGrid();
        tttBoard = Array.from({ length: 3 }, () => Array(3).fill(null));
        tttTurn = "X";
        tttWinner = null;
        tttWinLine = null;
        tttWinPulsing = false;
        tttRunning = true;
        setTttUI(true);
        renderTtt();
        setOuterPulseColor(5);
        log("Started Tic Tac Toe.");
      });

      connectFourBtn.addEventListener("click", () => {
        if (c4Running) {
          stopC4IfRunning();
          return;
        }
        stopRainbowIfRunning();
        stopLifeIfRunning();
        stopTttIfRunning();
        clearGrid();
        c4Board = Array.from({ length: 8 }, () => Array(8).fill(null));
        c4Turn = 1;
        c4Winner = null;
        c4WinLine = null;
        c4WinPulsing = false;
        c4Dropping = false;
        c4AiEnabled = false;
        c4AiPending = false;
        c4Running = true;
        setC4UI(true);
        setC4AiUI(false);
        renderC4();
        setOuterPulseColor(5);
        log("Started Connect Four.");
      });

      connectFourAiBtn.addEventListener("click", () => {
        if (c4Running && c4AiEnabled) {
          stopC4IfRunning();
          return;
        }
        stopRainbowIfRunning();
        stopLifeIfRunning();
        stopTttIfRunning();
        stopC4IfRunning();
        clearGrid();
        c4Board = Array.from({ length: 8 }, () => Array(8).fill(null));
        c4Turn = 1;
        c4Winner = null;
        c4WinLine = null;
        c4WinPulsing = false;
        c4Dropping = false;
        c4AiEnabled = true;
        c4AiPending = false;
        c4Running = true;
        setC4UI(false);
        setC4AiUI(true);
        renderC4();
        setOuterPulseColor(5);
        log("Started Connect Four (1P).");
      });

      if (!navigator.requestMIDIAccess) {
        log("Web MIDI is not supported in this browser.");
      }
    </script>
  </body>
</html>
